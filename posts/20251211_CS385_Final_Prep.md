---
title: "CS385 Lab Exam 3: Tactical Readiness Guide"
title_en: "CS385 Lab Exam 3: Tactical Readiness Guide"
title_zh: "CS385 å®éªŒè€ƒè¯• 3ï¼šæˆ˜æœ¯å‡†å¤‡æŒ‡å—"
date: 2025-12-11
author: "Dong Li"
categories: 
  - "CS385"
  - "React"
tags: 
  - "Object Manipulation"
  - "Rendering Patterns"
  - "Exam Strategy"
summary_en: "A targeted tactical guide for Lab Exam 3. Focusing on high-probability failure points: Nested Map patterns (Topic 10) and dynamic object property access. Includes diagnostic code snippets."
summary_zh: "é’ˆå¯¹å®éªŒè€ƒè¯• 3 çš„æˆ˜æœ¯æŒ‡å—ã€‚èšç„¦é«˜æ¦‚ç‡å¤±åˆ†ç‚¹ï¼šåµŒå¥—æ˜ å°„æ¨¡å¼ (Topic 10) å’ŒåŠ¨æ€å¯¹è±¡å±æ€§è®¿é—®ã€‚åŒ…å«è¯Šæ–­æ€§ä»£ç ç‰‡æ®µã€‚"
---

[EN]
# ğŸ›¡ï¸ Operational Readiness: Defcon 1

The final assessment for CS385 shifts focus from basic logic to **Advanced Object Manipulation**.
Based on an analysis of the Mock Exam and historical error patterns, I have identified 6 critical scenarios.
**Directive:** Analyze the code, predict the output, and verify.

---

### Scenario 1: The "Nested Map" Pattern (Topic 10 Core)
**Problem**: Rendering an object where property names are unknown at compile time.
**Analysis**:
*   `Object.keys(data)`: Returns keys.
*   `Object.getOwnPropertyNames(data)`: Returns keys (including non-enumerable ones, though usually identical for plain objects).
*   **Critical Error**: Using dot notation `data.k` when `k` is a variable string.

```javascript
const data = { id: 99, type: "Bus" };

// âŒ Incorrect: Looks for property literally named "k"
// Object.keys(data).map(k => <span>{data.k}</span>)

// âœ… Correct: Uses bracket notation to access value dynamically
Object.getOwnPropertyNames(data).map(k => <span>{data[k]}</span>)
```

<details> <summary style="cursor: pointer; color: #facc15; font-weight: bold;">â–¼ Logic Verification</summary>

**Rationale:**
1.  `Object.getOwnPropertyNames(data)` returns `["id", "type"]`.
2.  Inside the map, `k` is a **string**.
3.  `data.k` evaluates to `undefined`.
4.  `data[k]` evaluates to `99` then `"Bus"`.

</details>

---

### Scenario 2: Conditional Rendering Pitfalls
**Problem**: React rendering behavior with logical operators.
**Analysis**:
*   `true && expression` $\to$ `expression`
*   `false && expression` $\to$ `false` (React renders nothing)
*   `0 && expression` $\to$ `0` (React **renders 0**)

```javascript
const count = 0;
// âš ï¸ Renders "0" on screen
{count && <Component />}

// âœ… Renders nothing
{count > 0 && <Component />}
```

[END]

[ZH]
# ğŸ›¡ï¸ ä½œæˆ˜å‡†å¤‡ï¼šä¸€çº§æˆ’å¤‡

CS385 çš„æœ€ç»ˆè¯„ä¼°å°†é‡å¿ƒä»åŸºæœ¬é€»è¾‘è½¬ç§»åˆ°äº†**é«˜çº§å¯¹è±¡æ“ä½œ**ã€‚
åŸºäºå¯¹æ¨¡æ‹Ÿè€ƒè¯•å’Œå†å²é”™è¯¯æ¨¡å¼çš„åˆ†æï¼Œæˆ‘ç¡®å®šäº† 6 ä¸ªå…³é”®åœºæ™¯ã€‚
**æŒ‡ä»¤ï¼š** åˆ†æä»£ç ï¼Œé¢„æµ‹è¾“å‡ºï¼Œå¹¶éªŒè¯ã€‚

---

### åœºæ™¯ 1ï¼šâ€œåµŒå¥—æ˜ å°„â€æ¨¡å¼ (Topic 10 æ ¸å¿ƒ)
**é—®é¢˜**ï¼šæ¸²æŸ“ä¸€ä¸ªåœ¨ç¼–è¯‘æ—¶æœªçŸ¥å±æ€§åçš„å¯¹è±¡ã€‚
**åˆ†æ**ï¼š
*   `Object.keys(data)`ï¼šè¿”å›é”®ã€‚
*   `Object.getOwnPropertyNames(data)`ï¼šè¿”å›é”®ã€‚
*   **å…³é”®é”™è¯¯**ï¼šå½“ `k` æ˜¯å˜é‡å­—ç¬¦ä¸²æ—¶ä½¿ç”¨ç‚¹ç¬¦å· `data.k`ã€‚

```javascript
const data = { id: 99, type: "Bus" };

// âŒ é”™è¯¯ï¼šå¯»æ‰¾å­—é¢åä¸º "k" çš„å±æ€§
// Object.keys(data).map(k => <span>{data.k}</span>)

// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ‹¬å·ç¬¦å·åŠ¨æ€è®¿é—®å€¼
Object.getOwnPropertyNames(data).map(k => <span>{data[k]}</span>)
```

---

### åœºæ™¯ 2ï¼šæ¡ä»¶æ¸²æŸ“é™·é˜±
**é—®é¢˜**ï¼šå¸¦æœ‰é€»è¾‘è¿ç®—ç¬¦çš„ React æ¸²æŸ“è¡Œä¸ºã€‚
**åˆ†æ**ï¼š
*   `true && expression` $\to$ `expression`
*   `false && expression` $\to$ `false` (React ä»€ä¹ˆéƒ½ä¸æ¸²æŸ“)
*   `0 && expression` $\to$ `0` (React **æ¸²æŸ“ 0**)

```javascript
const count = 0;
// âš ï¸ åœ¨å±å¹•ä¸Šæ¸²æŸ“ "0"
{count && <Component />}

// âœ… ä»€ä¹ˆéƒ½ä¸æ¸²æŸ“
{count > 0 && <Component />}
```
[END]
